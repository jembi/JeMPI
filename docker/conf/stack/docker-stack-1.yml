version: '3.8'

networks:
  portainer:
    name: portainer
    driver: overlay
    attachable: true
  backend-kafka:
    name: backend-kafka
    driver: overlay
    attachable: true
  backend-dgraph:
    name: backend-dgraph
    driver: overlay
    attachable: true
  backend-cassandra:
    name: backend-cassandra
    driver: overlay
    attachable: true
  frontend-api:
    name: frontend-api
    driver: overlay
    attachable: true
  backend-prometheus:
    name: backend-prometheus
    driver: overlay
    attachable: true

volumes:
  portainer_data: 

services:

  agent:
    image: ${REGISTRY_NODE_IP}/$PORTAINER_AGENT_IMAGE 
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/volumes:/var/lib/docker/volumes
    networks:
      - portainer
    deploy:
      mode: global
      placement:
        constraints: [node.platform.os == linux]

  portainer:
    image: ${REGISTRY_NODE_IP}/$PORTAINER_IMAGE
    command: -H tcp://tasks.agent:9001 --tlsskipverify
    ports:
      - "9443:9443"
      - "9000:9000"
      - "8000:8000"
    volumes:
      - portainer_data:/data
    networks:
      - portainer
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints: [node.role == manager]

  kafka-1:
    image: ${REGISTRY_NODE_IP}/$KAFKA_IMAGE
    user: root
    networks:
      - backend-kafka
    environment:
      BITNAMI_DEBUG: 'true'
      KAFKA_ENABLE_KRAFT: 'yes'
      KAFKA_KRAFT_CLUSTER_ID: 'ehB92ChxEe2iYQAAAkKsEg'
      KAFKA_CFG_NODE_ID: 1
      KAFKA_CFG_BROKER_ID: 1
      KAFKA_CFG_PROCESS_ROLES: 'broker,controller'
      KAFKA_CFG_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_CFG_LISTENERS: PLAINTEXT://:9092,CONTROLLER://:9093
      KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT
      KAFKA_CFG_ADVERTISED_LISTENERS: PLAINTEXT://kafka-1:9092
      KAFKA_CFG_CONTROLLER_QUORUM_VOTERS: 1@kafka-1:9093,2@kafka-2:9093,3@kafka-3:9093
      KAFKA_CFG_INTER_BROKER_LISTENER_NAME: PLAINTEXT  
      ALLOW_PLAINTEXT_LISTENER: 'yes'
    volumes:
      - type: bind
        source: ${DATA_KAFKA_1_DIR}
        target: /bitnami/kafka
        read_only: false
    deploy:
      mode: replicated
      replicas: ${SCALE_KAFKA_1}
      resources:
        limits:
          memory: ${KAFKA_1_LIMIT_MEMORY}
        reservations:
          memory: ${KAFKA_1_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.hostname == $PLACEMENT_KAFKA_1        
  
  kafka-2:
    image: ${REGISTRY_NODE_IP}/$KAFKA_IMAGE 
    user: root
    networks:
      - backend-kafka
    environment:
      BITNAMI_DEBUG: 'true'
      KAFKA_ENABLE_KRAFT: 'yes'
      KAFKA_KRAFT_CLUSTER_ID: 'ehB92ChxEe2iYQAAAkKsEg'
      KAFKA_CFG_NODE_ID: 2
      KAFKA_CFG_BROKER_ID: 2
      KAFKA_CFG_PROCESS_ROLES: 'broker,controller'
      KAFKA_CFG_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_CFG_LISTENERS: PLAINTEXT://:9092,CONTROLLER://:9093
      KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT
      KAFKA_CFG_ADVERTISED_LISTENERS: PLAINTEXT://kafka-2:9092
      KAFKA_CFG_CONTROLLER_QUORUM_VOTERS: 1@kafka-1:9093,2@kafka-2:9093,3@kafka-3:9093
      KAFKA_CFG_INTER_BROKER_LISTENER_NAME: PLAINTEXT  
      ALLOW_PLAINTEXT_LISTENER: 'yes' 
    volumes:
      - type: bind
        source: ${DATA_KAFKA_2_DIR}
        target: /bitnami/kafka
        read_only: false
    deploy:
      mode: replicated
      replicas:  ${SCALE_KAFKA_2}
      resources:
        limits:
          memory: ${KAFKA_2_LIMIT_MEMORY}
        reservations:
          memory: ${KAFKA_2_RESERVATION_MEMORY} 
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.hostname == $PLACEMENT_KAFKA_2        
  
  kafka-3:
    image: ${REGISTRY_NODE_IP}/$KAFKA_IMAGE 
    user: root
    networks:
      - backend-kafka
    environment:
      BITNAMI_DEBUG: 'true'
      KAFKA_ENABLE_KRAFT: 'yes'
      KAFKA_KRAFT_CLUSTER_ID: 'ehB92ChxEe2iYQAAAkKsEg'
      KAFKA_CFG_NODE_ID: 3
      KAFKA_CFG_BROKER_ID: 3
      KAFKA_CFG_PROCESS_ROLES: 'broker,controller'
      KAFKA_CFG_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_CFG_LISTENERS: PLAINTEXT://:9092,CONTROLLER://:9093
      KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT
      KAFKA_CFG_ADVERTISED_LISTENERS: PLAINTEXT://kafka-3:9092
      KAFKA_CFG_CONTROLLER_QUORUM_VOTERS: 1@kafka-1:9093,2@kafka-2:9093,3@kafka-3:9093
      KAFKA_CFG_INTER_BROKER_LISTENER_NAME: PLAINTEXT  
      ALLOW_PLAINTEXT_LISTENER: 'yes' 
    volumes:
      - type: bind
        source: ${DATA_KAFKA_3_DIR}
        target: /bitnami/kafka
        read_only: false
    deploy:
      mode: replicated
      replicas:  ${SCALE_KAFKA_3}
      resources:
        limits:
          memory: ${KAFKA_3_LIMIT_MEMORY}
        reservations:
          memory: ${KAFKA_3_RESERVATION_MEMORY}  
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.hostname == $PLACEMENT_KAFKA_3   

  zero:
    image: ${REGISTRY_NODE_IP}/${DGRAPH_IMAGE}
    hostname: "zero"
    networks:
    - backend-dgraph
    ports:
    - published: 5080
      target: 5080
      protocol: tcp
      mode: host
    - published: 6080
      target: 6080
      protocol: tcp
      mode: host
    volumes:
    - type: bind
      source: ${DATA_DGRAPH_ZERO_DIR}
      target: /dgraph
    deploy:
      replicas: $SCALE_ZERO
      resources:
        limits:
          memory: ${ZERO_LIMIT_MEMORY}
        reservations:
          memory: ${ZERO_RESERVATION_MEMORY}    
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_DGRAPH_ZERO}
    command: dgraph zero --my=zero:5080 --replicas 1

  alpha1:
    image: ${REGISTRY_NODE_IP}/${DGRAPH_IMAGE}
    hostname: "alpha1"
    networks:
    - backend-dgraph
    volumes:
    - type: bind
      source: ${DATA_DGRAPH_ALPHA1_DIR}
      target: /dgraph
    ports:
    - published: 8080
      target: 8080
      protocol: tcp
      mode: host
    - published: 9080
      target: 9080
      protocol: tcp
      mode: host
    deploy:
      replicas: ${SCALE_ALPHA1}
      resources:
        limits:
          memory: ${ALPHA_1_LIMIT_MEMORY}
        reservations:
          memory: ${ALPHA_1_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_DGRAPH_ALPHA1}
    command: dgraph alpha --my=alpha1:7080 --zero=zero:5080 --security whitelist=0.0.0.0/0 --lambda url=http://lambda:8686/graphql-worker --telemetry "sentry=false;"

  alpha2:
    image: ${REGISTRY_NODE_IP}/${DGRAPH_IMAGE}
    hostname: "alpha2"
    networks:
    - backend-dgraph
    volumes:
    - type: bind
      source: ${DATA_DGRAPH_ALPHA2_DIR}
      target: /dgraph
    ports:
    - published: 8081
      target: 8081
      protocol: tcp
      mode: host
    - published: 9081
      target: 9081
      protocol: tcp
      mode: host
    deploy:
      replicas: ${SCALE_ALPHA2}
      resources:
        limits:
          memory: ${ALPHA_2_LIMIT_MEMORY}
        reservations:
          memory: ${ALPHA_2_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_DGRAPH_ALPHA2}
    command: dgraph alpha --my=alpha2:7081 --zero=zero:5080 --security whitelist=0.0.0.0/0 -o 1 --lambda url=http://lambda:8686/graphql-worker --telemetry "sentry=false;"

  alpha3:
    image: ${REGISTRY_NODE_IP}/${DGRAPH_IMAGE}
    hostname: "alpha3"
    networks:
    - backend-dgraph
    volumes:
    - type: bind
      source: ${DATA_DGRAPH_ALPHA3_DIR}
      target: /dgraph
    ports:
    - published: 8082
      target: 8082
      protocol: tcp
      mode: host
    - published: 9082
      target: 9082
      protocol: tcp
      mode: host
    deploy:
      replicas: ${SCALE_ALPHA3}
      resources:
        limits:
          memory: ${ALPHA_3_LIMIT_MEMORY}
        reservations:
          memory: ${ALPHA_3_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_DGRAPH_ALPHA3}
    command: dgraph alpha --my=alpha3:7082 --zero=zero:5080 --security whitelist=0.0.0.0/0 -o 2 --lambda url=http://lambda:8686/graphql-worker --telemetry "sentry=false;"

  lambda:
    image: ${REGISTRY_NODE_IP}/${DGRAPH_LAMBDA_IMAGE}
    ports:
    - published: 8686
      target: 8686
      protocol: tcp
      mode: host                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    networks:
    - backend-dgraph
    environment:
      DGRAPH_URL: http://alpha1:8080
    volumes:
    - type: bind
      source: ${DATA_DGRAPH_LAMBDA_DIR}
      target: /app/script/script.js:ro
    deploy:
      replicas: ${SCALE_LAMBDA}
      resources:
        limits:
          memory: ${LAMBDA_LIMIT_MEMORY}
        reservations:
          memory: ${LAMBDA_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_DGRAPH_LAMBDA}

  ratel:
    image: ${REGISTRY_NODE_IP}/${RATEL_IMAGE}
    ports:
    - published: 8010
      target: 8000
      protocol: tcp
      mode: host                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    networks:
    - backend-dgraph
    deploy:
      replicas: 1
      resources:
        limits:
          memory: ${RATEL_LIMIT_MEMORY}
        reservations:
          memory: ${RATEL_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_RATEL}
    command: dgraph-ratel
    
  cassandra-1:
    image: ${REGISTRY_NODE_IP}/${CASSANDRA_IMAGE}
    user: root
    hostname: "cassandra-1"
    networks:
    - backend-cassandra
    ports:
    - published: 9042
      target: 9042
      protocol: tcp
      mode: host                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    environment:
      CASSANDRA_CLUSTER_NAME: cassandra-cluster
      CASSANDRA_SEEDS: cassandra-1,cassandra-2,cassandra-3
      CASSANDRA_DATACENTER: datacenter1
      CASSANDRA_RACK: rack1
      CASSANDRA_ENABLE_USER_DEFINED_FUNCTIONS: 'true'
      CASSANDRA_ENABLE_SCRIPTED_USER_DEFINED_FUNCTIONS: 'true'
    volumes:
    - type: bind
      source: ${DATA_CASSANDRA_1_DIR}/data
      target: /bitnami
    - type: bind
      source: ${DATA_CASSANDRA_1_DIR}/cassandra.yaml
      target: /bitnami/cassandra/conf/cassandra.yaml
      read_only: true
    deploy:
      replicas: ${SCALE_CASSANDRA_1}
      # resources:
      #   limits:
      #     memory: ${CASSANDRA_1_LIMIT_MEMORY}
      #   reservations:
      #     memory: ${CASSANDRA_1_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_CASSANDRA_1}
     
  cassandra-2:
    image: ${REGISTRY_NODE_IP}/${CASSANDRA_IMAGE}
    user: root
    hostname: "cassandra-2"
    networks:
    - backend-cassandra
    ports:
    - published: 9043
      target: 9042
      protocol: tcp
      mode: host      
    environment:
      CASSANDRA_CLUSTER_NAME: cassandra-cluster
      CASSANDRA_SEEDS: cassandra-1,cassandra-2,cassandra-3
      CASSANDRA_DATACENTER: datacenter1
      CASSANDRA_RACK: rack1
      CASSANDRA_ENABLE_USER_DEFINED_FUNCTIONS: 'true'
      CASSANDRA_ENABLE_SCRIPTED_USER_DEFINED_FUNCTIONS: 'true'
    volumes:
    - type: bind
      source: ${DATA_CASSANDRA_2_DIR}/data
      target: /bitnami
    - type: bind
      source: ${DATA_CASSANDRA_2_DIR}/cassandra.yaml
      target: /bitnami/cassandra/conf/cassandra.yaml
      read_only: true
    deploy:
      replicas: ${SCALE_CASSANDRA_2}
      # resources:
      #   limits:
      #     memory: ${CASSANDRA_2_LIMIT_MEMORY}
      #   reservations:
      #     memory: ${CASSANDRA_2_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_CASSANDRA_2}

  cassandra-3:
    image: ${REGISTRY_NODE_IP}/${CASSANDRA_IMAGE}
    user: root
    hostname: "cassandra-3"
    networks:
    - backend-cassandra
    ports:
    - published: 9044
      target: 9042
      protocol: tcp
      mode: host      
    environment:
      CASSANDRA_CLUSTER_NAME: cassandra-cluster
      CASSANDRA_SEEDS: cassandra-1,cassandra-2,cassandra-3
      CASSANDRA_DATACENTER: datacenter1
      CASSANDRA_RACK: rack1
      CASSANDRA_ENABLE_USER_DEFINED_FUNCTIONS: 'true'
      CASSANDRA_ENABLE_SCRIPTED_USER_DEFINED_FUNCTIONS: 'true'
    volumes:
    - type: bind
      source: ${DATA_CASSANDRA_3_DIR}/data
      target: /bitnami
    - type: bind
      source: ${DATA_CASSANDRA_3_DIR}/cassandra.yaml
      target: /bitnami/cassandra/conf/cassandra.yaml
      read_only: true
    deploy:
      replicas: ${SCALE_CASSANDRA_1}
      # resources:
      #   limits:
      #     memory: ${CASSANDRA_3_LIMIT_MEMORY}
      #   reservations:
      #     memory: ${CASSANDRA_3_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_CASSANDRA_3}

  journal:
    image: ${REGISTRY_NODE_IP}/${JOURNAL_IMAGE}
    networks:
    - backend-kafka
    volumes:
    - type: bind
      source: $DATA_DIR_JOURNAL/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_JOURNAL/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${JOURNAL_LIMIT_MEMORY}
        reservations:
          memory: ${JOURNAL_RESERVATION_MEMORY}      
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_JOURNAL}        

  notifications:
    image: ${REGISTRY_NODE_IP}/${NOTIFICATIONS_IMAGE}
    networks:
    - backend-kafka
    volumes:
    - type: bind
      source: $DATA_DIR_NOTIFICATIONS/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_NOTIFICATIONS/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${NOTIFICATIONS_LIMIT_MEMORY}
        reservations:
          memory: ${NOTIFICATIONS_RESERVATION_MEMORY}      
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_NOTIFICATIONS}        

  test-01:
    image: ${REGISTRY_NODE_IP}/${TEST_01_IMAGE}
    networks:
    - backend-kafka
    volumes:
    - type: bind
      source: $DATA_DIR_TEST_01/logs
      target: /app/logs
      read_only: false
    - type: bind
      source: $DATA_DIR_TEST_01/csv
      target: /app/csv
      read_only: true
    - type: bind
      source: $DATA_DIR_TEST_01/conf
      target: /app/conf
      read_only: true
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${TEST_01_LIMIT_MEMORY}
        reservations:
          memory: ${TEST_01_RESERVATION_MEMORY}     
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_TEST_01}

  staging-01:
    image: ${REGISTRY_NODE_IP}/${STAGING_01_IMAGE}
    networks:
    - backend-kafka
    volumes:
    - type: bind
      source: $DATA_DIR_STAGING_01/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_STAGING_01/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${STAGING_01_LIMIT_MEMORY}
        reservations:
          memory: ${STAGING_01_RESERVATION_MEMORY}       
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_STAGING_01}
   
  controller:
    image: ${REGISTRY_NODE_IP}/${CONTROLLER_IMAGE}
    networks:
    - backend-kafka
    ports:
    - published: 50020
      target: 50000
      protocol: tcp
      mode: host      
    volumes:
    - type: bind
      source: $DATA_DIR_CONTROLLER/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_CONTROLLER/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${CONTROLLER_LIMIT_MEMORY}
        reservations:
          memory: ${CONTROLLER_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_CONTROLLER}
       
  em:
    image: ${REGISTRY_NODE_IP}/${EM_IMAGE}
    networks:
    - backend-kafka
    - backend-cassandra
    - backend-prometheus
    ports:
    - published: 90
      target: 90
      protocol: tcp
      mode: host 
    volumes:
    - type: bind
      source: $DATA_DIR_EM/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_EM/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          cpus: "2.0"
          memory: ${EM_LIMIT_MEMORY}
        reservations:
          memory: ${EM_RESERVATION_MEMORY}        
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_EM}

  linker:
    image: ${REGISTRY_NODE_IP}/${LINKER_IMAGE}
    networks:
    - backend-kafka
    - backend-dgraph
    - backend-cassandra
    - backend-prometheus
    ports:
    - published: 50010
      target: 50000
      protocol: tcp
      mode: host  
    volumes:
    - type: bind
      source: $DATA_DIR_LINKER/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_LINKER/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${LINKER_LIMIT_MEMORY}
        reservations:
          memory: ${LINKER_RESERVATION_MEMORY}  
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_LINKER}

  api:
    image: ${REGISTRY_NODE_IP}/${API_IMAGE}
    networks:
    - backend-dgraph
    - backend-cassandra
    - frontend-api
    ports:
    - published: 50000
      target: 50000
      protocol: tcp
      mode: host  
    volumes:
    - type: bind
      source: $DATA_DIR_API/conf
      target: /app/conf
      read_only: true
    - type: bind
      source: $DATA_DIR_API/logs
      target: /app/logs
      read_only: false
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          memory: ${API_LIMIT_MEMORY}
        reservations:
          memory: ${API_RESERVATION_MEMORY}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 0
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_API}
    
  prometheus:
    image: ${REGISTRY_NODE_IP}/${PROMETHEUS_IMAGE}
    user: root
    hostname: "prometheus"
    networks:
    - backend-prometheus
    ports:
    - published: 9090
      target: 9090
      protocol: tcp
      mode: host      
    volumes:
    - type: bind
      source: ${DATA_PROMETHEUS_DIR}/prometheus.yml
      target: /etc/prometheus/prometheus.yml
      read_only: true
    - type: bind
      source: ${DATA_PROMETHEUS_DIR}/daemon.json
      target: /etc/docker/daemon.json
      read_only: true
    deploy:
      replicas: ${SCALE_PROMETHEUS}
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
        - node.hostname == ${PLACEMENT_PROMETHEUS}