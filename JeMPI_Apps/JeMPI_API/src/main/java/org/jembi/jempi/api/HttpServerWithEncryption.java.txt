package org.jembi.jempi.api;

import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.model.HttpEntity;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.ExceptionHandler;
import akka.http.javadsl.server.RejectionHandler;
import akka.http.javadsl.server.Route;
import ch.megard.akka.http.cors.javadsl.settings.CorsSettings;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.config.Configurator;
import org.jembi.jempi.AppConfig;
import org.jembi.jempi.libapi.BackEnd;
import org.jembi.jempi.libapi.Routes;
import org.jembi.jempi.shared.models.GlobalConstants;

import java.util.concurrent.CompletionStage;

import org.jembi.jempi.shared.utils.CryptoUtils;
import org.jembi.jempi.shared.utils.VaultUtils;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class HttpServerWithEncryption extends AllDirectives {

   private static final Logger LOGGER = LogManager.getLogger(HttpServerWithEncryption.class);

   private final SecretKey secretKey;
   private CompletionStage<ServerBinding> binding;
   private Http http;

   public HttpServerWithEncryption(SecretKey secretKey) {
      this.secretKey = secretKey;
   }

   public static HttpServerWithEncryption create(String vaultAddress, String vaultToken, String keyPath) {
      try {
         SecretKey key = VaultUtils.retrieveSecretKey(vaultAddress, vaultToken, keyPath);
         return new HttpServerWithEncryption(key);
      } catch (Exception e) {
         LOGGER.error("Error retrieving secret key from Vault", e);
         throw new RuntimeException("Failed to initialize HttpServerWithEncryption", e);
      }
   }

   public void open(
         final String httpServerHost,
         final int httpPort,
         final ActorSystem<Void> actorSystem,
         final ActorRef<BackEnd.Event> backEnd,
         final String jsonFields) {
      http = Http.get(actorSystem);
      binding = http.newServerAt(httpServerHost, httpPort)
            .bind(this.createCorsRoutes(actorSystem, backEnd, jsonFields));
      LOGGER.info("Server online at http://{}:{}", httpServerHost, httpPort);
   }

   public void close(final ActorSystem<Void> actorSystem) {
      binding.thenCompose(ServerBinding::unbind) // trigger unbinding from the port
            .thenAccept(unbound -> actorSystem.terminate()); // shutdown when done
   }

   // private Route createCoreAPIRoutes(
   // final ActorSystem<Void> actorSystem,
   // final ActorRef<BackEnd.Event> backEnd,
   // final String jsonFields) {
   // return pathPrefix("JeMPI", () -> concat(
   // path(GlobalConstants.SEGMENT_POST_FIELDS_CONFIG, () ->
   // complete(StatusCodes.OK, jsonFields)),
   // path("encryptDecryptRoute", () -> entity(Unmarshaller.entityToString(), body
   // -> {
   // try {
   // String decryptedBody = CryptoUtils.decrypt(body, secretKey);
   // String encryptedResponse = CryptoUtils.encrypt(decryptedBody, secretKey);

   // return complete(HttpEntity .create(encryptedResponse));
   // } catch (Exception e) {
   // LOGGER.error("Encryption/Decryption error", e);
   // return complete(StatusCodes.INTERNAL_SERVER_ERROR, "Encryption/Decryption
   // error");
   // }
   // }))));
   // }

   public Route createCorsRoutes(
         final ActorSystem<Void> actorSystem,
         final ActorRef<BackEnd.Event> backEnd,
         final String jsonFields) {
      final var settings = CorsSettings.create(AppConfig.CONFIG);

      final RejectionHandler rejectionHandler = RejectionHandler.defaultHandler().mapRejectionResponse(response -> {
         if (response.entity() instanceof HttpEntity.Strict) {
            String message = ((HttpEntity.Strict) response.entity()).getData().utf8String();
            LOGGER.warn(String.format("Request was rejected. Reason: %s", message));
         }

         return response;
      });

      final ExceptionHandler exceptionHandler = ExceptionHandler.newBuilder().match(Exception.class, x -> {
         LOGGER.error("An exception occurred while executing the Route", x);
         return complete(StatusCodes.INTERNAL_SERVER_ERROR, "An exception occurred, see server logs for details");
      }).build();

      return cors(settings,
            () -> pathPrefix("JeMPI",
                  () -> concat(Routes.createCoreAPIRoutes(actorSystem,
                        backEnd,
                        jsonFields,
                        AppConfig.LINKER_IP,
                        AppConfig.LINKER_HTTP_PORT,
                        AppConfig.CONTROLLER_IP,
                        AppConfig.CONTROLLER_HTTP_PORT,
                        http),
                        path(GlobalConstants.SEGMENT_GET_FIELDS_CONFIG,
                              () -> complete(StatusCodes.OK, jsonFields)))))
            .seal(rejectionHandler,
                  exceptionHandler);
   }
}
